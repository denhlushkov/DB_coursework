# Опис схеми бази даних 

Цей звіт описує реляційну схему PostgreSQL, створену на основі ER-діаграми для системи управління клінікою. Схема призначена для обліку пацієнтів, терапевтів, сеансів, медичних записів та фінансових операцій (рахунків та платежів).

### Діаграма ER:

<img width="1875" height="2194" alt="diagram" src="https://github.com/user-attachments/assets/a74d520a-8abd-443f-a94f-3ae33b1bd59f" />

## Детальний опис кожної таблиці, її стовпців, ключів та ключових обмежень:

### 1. Schedule (Розклад)

**Призначення:** Зберігає інформацію про часові слоти для розкладу лікарів. Визначає доступність конкретного проміжку часу для запису.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| schedule_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор слоту розкладу |
| date | DATE | NOT NULL | Дата робочого дня |
| start_time | TIME | NOT NULL | Час початку слоту |
| end_time | TIME | NOT NULL | Час закінчення слоту |
| is_available | BOOLEAN | DEFAULT true | Прапорець доступності (вільно/зайнято) |

**Індекси:**
- `idx_schedule_date_avail` - Складений індекс `(date, is_available)` для швидкого пошуку вільних вікон на конкретну дату.

**Зв'язки:**
- **Один-до-Одного** з таблицею `Therapist` (лікар посилається на цей запис у розкладі).

**Рішення при проектуванні:**
- Використання `CHECK (end_time > start_time)` на рівні БД для запобігання логічних помилок (кінець не може бути раніше початку).
- Поле `is_available` дозволяє швидко фільтрувати слоти без необхідності робити складні перевірки по таблиці `Session`.

---

### 2. Diagnosis (Діагнози)

**Призначення:** Довідник можливих діагнозів. Дозволяє стандартизувати назви хвороб та їх класифікацію.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| diagnosis_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор діагнозу |
| title | VARCHAR(150) | UNIQUE, NOT NULL | Назва діагнозу (унікальна) |
| description | TEXT | NULL | Детальний опис симптомів та характеристик |
| severity_level | ENUM | DEFAULT 'Low' | Рівень тяжкості ('Low', 'Medium', 'High', 'Critical') |

**Зв'язки:**
- **Один-до-Багатьох** з таблицею `Patient` (один діагноз може бути встановлений багатьом пацієнтам).

**Рішення при проектуванні:**
- Використання типу `ENUM` для `severity_level` забезпечує строгу валідацію даних (не можна вписати неіснуючий рівень) та економить пам'ять.

---

### 3. Procedure (Процедури)

**Призначення:** Каталог медичних процедур, їхня базова вартість та тривалість виконання.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| procedure_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор процедури |
| title | VARCHAR(150) | UNIQUE, NOT NULL | Назва процедури |
| cost | NUMERIC(10, 2) | NOT NULL, CHECK >= 0 | Вартість послуги |
| duration_minutes | INTEGER | NOT NULL, CHECK > 0 | Стандартна тривалість виконання у хвилинах |

**Зв'язки:**
- **Один-до-Багатьох** з таблицею `Session` (процедура використовується у багатьох сеансах).

**Рішення при проектуванні:**
- Тип `NUMERIC(10, 2)` використовується для грошових значень, щоб уникнути помилок округлення, які властиві типу `FLOAT`.

---

### 4. Medical_Record (Медична Карта)

**Призначення:** Зберігає історію хвороби, нотатки лікаря.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| medical_rec_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор медкарти |
| date | DATE | DEFAULT NOW() | Дата створення запису |
| notes | TEXT | NULL | Текстові нотатки лікаря |
| photo | TEXT | NULL | URL або шлях до файлу |

**Зв'язки:**
- **Один-до-Одного** з таблицею `Patient`.

**Рішення при проектуванні:**
- Поле `photo` зберігає лише шлях до файлу (`TEXT`), а не сам файл (BLOB), що значно зменшує навантаження на базу даних.

---

### 5. Patient (Пацієнти)

**Призначення:** Зберігає персональні дані пацієнтів та посилання на їхню медичну інформацію.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| patient_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор пацієнта |
| name | VARCHAR(100) | NOT NULL | ПІБ пацієнта |
| birth_date | DATE | NOT NULL | Дата народження |
| phone | VARCHAR(20) | UNIQUE, NOT NULL | Контактний номер телефону |
| diagnosis_id | INTEGER | FK, NULL | Посилання на основний діагноз |
| medical_rec_id | INTEGER | FK, UNIQUE, NOT NULL | Посилання на медичну карту |

**Індекси:**
- `idx_patient_phone` - Унікальний індекс по `phone` для миттєвого пошуку картки в реєстратурі.
- `idx_patient_name` - Індекс по `name` для пошуку за прізвищем.

**Зв'язки:**
- **Багато-до-Одного** з `Diagnosis`.
- **Один-до-Одного** з `Medical_Record` (унікальний зовнішній ключ).
- **Один-до-Багатьох** з `Session`.

**Рішення при проектуванні:**
- Правило `ON DELETE RESTRICT` для сесій: система не дозволить видалити пацієнта, якщо у нього є історія візитів, щоб зберегти фінансову звітність.

---

### 6. Therapist (Лікарі)

**Призначення:** Зберігає профілі лікарів, їхню спеціалізацію та статус роботи.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| therapist_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор лікаря |
| name | VARCHAR(100) | NOT NULL | ПІБ лікаря |
| specialization | VARCHAR(100) | NULL | Спеціалізація (напр. "Хірург") |
| phone | VARCHAR(20) | UNIQUE | Контактний телефон |
| photo | TEXT | NULL | URL фотографії профілю |
| is_active | BOOLEAN | DEFAULT true | Статус активності (для soft delete) |
| schedule_id | INTEGER | FK, NULL | Посилання на запис у розкладі |

**Індекси:**
- `idx_therapist_name` - Індекс для пошуку лікаря за ім'ям.

**Зв'язки:**
- **Один-до-Багатьох** з `Session` (лікар проводить багато сеансів).
- **Багато-до-Одного** з `Schedule`.

**Рішення при проектуванні:**
- `is_active` реалізує паттерн "Soft Delete": при звільненні лікаря ми не видаляємо запис фізично (щоб не ламати історію минулих сеансів), а просто деактивуємо його.

---

### 7. Session (Сеанси/Візити)

**Призначення:** Центральна таблиця системи. Фіксує факт запланованого або проведеного візиту.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| session_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор сеансу |
| date | DATE | NOT NULL | Дата візиту |
| start_time | TIME | NOT NULL | Точний час початку візиту |
| duration_minutes | INTEGER | NOT NULL | Фактична тривалість |
| status | ENUM | DEFAULT 'Scheduled' | Статус ('Scheduled', 'Completed', 'Cancelled') |
| room_number | VARCHAR(10) | NULL | Номер кабінету |
| procedure_id | INTEGER | FK, NOT NULL | Посилання на процедуру |
| patient_id | INTEGER | FK, NOT NULL | Посилання на пацієнта |
| therapist_id | INTEGER | FK, NOT NULL | Посилання на лікаря |

**Індекси:**
- `idx_session_therapist_date` - Складений індекс `(therapist_id, date)` для швидкої перевірки зайнятості лікаря на конкретний день.
- `idx_session_status` - Індекс для аналітики (скільки завершених/скасованих візитів).

**Зв'язки:**
- **Один-до-Багатьох** з `Invoice` 
- **Багато-до-Одного** з `Procedure` (процедура використовується у багатьох сеансах).
- **Багато-до-Одного** з `Patient` 
- **Багато-до-Одного** з `Therapist` (лікар проводить багато сеансів).

---

### 8. Invoice (Рахунки)

**Призначення:** Фінансовий документ, що автоматично формується на основі сеансу.

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| invoice_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор рахунку |
| amount | NUMERIC(10, 2) | NOT NULL, CHECK >= 0 | Сума до сплати |
| issue_date | DATE | DEFAULT NOW() | Дата виставлення рахунку |
| session_id | INTEGER | FK, UNIQUE, NOT NULL | Посилання на сеанс |

**Зв'язки:**
- **Один-до-Одного** з `Session`.
- **Один-до-Багатьох** з `Payment` (один рахунок може бути оплачений частинами).

**Рішення при проектуванні:**
- Поле `session_id` є унікальним (`UNIQUE`), що гарантує бізнес-правило "Один сеанс — один рахунок".

---

### 9. Payment (Оплати)

**Призначення:** Фіксує фактичні надходження коштів (транзакції).

**Колонки:**

| Колонка | Тип | Обмеження | Опис |
|---------|-----|-----------|------|
| payment_id | SERIAL | PRIMARY KEY | Унікальний ідентифікатор транзакції |
| amount | NUMERIC(10, 2) | NOT NULL, CHECK > 0 | Сплачена сума |
| payment_date | DATE | DEFAULT NOW() | Дата транзакції |
| method | ENUM | NOT NULL | Метод оплати ('Cash', 'Card', 'Bank Transfer') |
| invoice_id | INTEGER | FK, NOT NULL | Посилання на рахунок, що оплачується |

**Зв'язки:**
- **Багато-до-Одного** з `Invoice`.

**Рішення при проектуванні:**
- Використання `ENUM` для методів оплати спрощує побудову фінансових звітів (фільтрація за типом: готівка/картка).

  

## Перерахування (Enums)



### Severity Enum

Використовується в таблиці `Diagnosis` для визначення тяжкості захворювання.

```typescript
enum Severity {
  Low       // Низький рівень загрози
  Medium    // Середній рівень
  High      // Високий рівень
  Critical  // Критичний стан
}

```

### SessionStatus Enum

Використовується в таблиці `Session` для відстеження життєвого циклу візиту.

```typescript
enum SessionStatus {
  Scheduled  // Заплановано
  Completed  // Завершено (пацієнт був, послуга надана)
  Cancelled  // Скасовано (пацієнт не прийшов або лікар скасував)
}

```

### PaymentMethod Enum

Використовується в таблиці `Payment` для фінансової звітності.

```typescript
enum PaymentMethod {
  Cash           // Готівка
  Card           // Банківська картка
  Bank_Transfer  // Банківський переказ (страхова/юр. особа)
}

```

---

## Аналіз Нормалізації

### Перша Нормальна Форма (1NF)

✅ Усі таблиці містять атомарні значення (жодних масивів у клітинках).

✅ Кожна колонка містить значення одного типу.

✅ Унікальні імена колонок.

✅ Відсутні повторювані групи.

### Друга Нормальна Форма (2NF)

✅ Відповідає вимогам 1NF.

✅ Усі неключові атрибути повністю залежать від первинного ключа. Оскільки ми використовуємо сурогатні ключі (`SERIAL`), часткових залежностей немає за визначенням.

### Третя Нормальна Форма (3NF)

✅ Відповідає вимогам 2NF.

✅ Відсутні транзитивні залежності (всі неключові атрибути залежать лише від PK).

**Приклад дотримання:**

* Телефон лікаря зберігається в `Therapist`, а не дублюється в `Session`.
* Вартість процедури зберігається в `Procedure` і підтягується при створенні інвойсу, не дублюючись у кожному записі сесії (окрім фінального чеку `Invoice`, де це необхідно для фіксування історичної ціни).

---

## Стратегія Індексації

### Первинні Індекси (Автоматичні)

Всі обмеження `PRIMARY KEY` автоматично створюють унікальні індекси B-Tree.

### Індекси Зовнішніх Ключів (Foreign Key Indexes)

Індекси на колонках зовнішніх ключів для прискорення операцій `JOIN` та фільтрації:

* **`Therapist` `schedule_id`** - Для відображення профілю лікаря разом з його графіком.
* **`Patient` `diagnosis_id`** - Для аналітики захворювань та фільтрації пацієнтів за діагнозом.
* **`Patient` `medical_rec_id`** - Для швидкого переходу до медкарти з профілю пацієнта.
* **`Session` `patient_id`** - Для виводу історії візитів в особистому кабінеті пацієнта.
* **`Session` `therapist_id`** - Для формування календаря лікаря та розрахунку навантаження.
* **`Session` `procedure_id`** - Для статистики популярності медичних послуг.
* **`Invoice` `session_id`** - Для автоматичної генерації чеку після візиту.
* **`Payment` `invoice_id`** - Для перевірки статусу оплати (борг/оплачено).

### Складені Індекси (Composite Indexes)

* **`Schedule` `(date, is_available)`**
* **Призначення:** Швидкий пошук вільних вікон на конкретну дату.
* **Використання:** Віджет "Записатися на прийом", де показуються тільки доступні слоти.


* **`Session` `(therapist_id, date)`**
* **Призначення:** Перевірка зайнятості лікаря.
* **Використання:** Валідація при створенні нового запису, щоб уникнути накладання (double booking).



### Індекси для Пошуку (Search Indexes)

* **`Patient` `phone` (UNIQUE)** - Основний ідентифікатор в реєстратурі. Дозволяє миттєво знайти картку при вхідному дзвінку.
* **`Therapist` `name`** - Для пошуку лікаря пацієнтом на сайті.

---

## Рішення при Проектуванні (Design Decisions & Trade-offs)

### 1. Soft Delete для Лікарів (`is_active`)

**Рішення:** Використовувати прапорець `is_active` замість фізичного видалення запису з таблиці `Therapist`.

**Плюси:**
* Зберігає історичну цілісність (сеанси, проведені звільненим лікарем, не зникають із бази).
  
**Мінуси:**
* Потрібно додавати умову `WHERE is_active = true` при вибірці актуального списку лікарів.

### 2. Фотографії як посилання

**Рішення:** Зберігати в базі (`photo` TEXT) лише шлях до файлу або URL, а не саме зображення (BLOB).
**Плюси:** База даних залишається легкою та швидкою.
**Мінуси:** Потребує зовнішнього сховища файлів.

### 3. Зв'язок 1:1 для Medical Record

**Рішення:** Пацієнт має жорсткий зв'язок 1:1 з медкартою (`UNIQUE` FK).
**Обґрунтування:** Гарантує, що у пацієнта лише одна активна історія хвороби, що спрощує логіку роботи реєстратури.

---

## Каскадна Поведінка (Cascade Behavior)

| Батьківська (Parent) | Дочірня (Child) | Поведінка | Пояснення |
| --- | --- | --- | --- |
| **Patient** → **MedicalRecord** | `ON DELETE CASCADE` | Видалення пацієнта видаляє медкарту | Якщо немає людини, її карта стає неактуальною. |
| **Session** → **Invoice** | `ON DELETE CASCADE` | Видалення сеансу видаляє рахунок | Якщо запис був створений помилково і видалений, борг анулюється. |
| **Therapist** → **Schedule** | `ON DELETE SET NULL` | Видалення лікаря очищає слот | Слот залишається в сітці розкладу, але стає "нічийним". |
| **Patient** → **Session** | `ON DELETE RESTRICT` | **Заборона** | Не можна видалити пацієнта, якщо він вже відвідував лікарів (фінансова безпека). |
| **Therapist** → **Session** | `ON DELETE RESTRICT` | **Заборона** | Не можна видалити лікаря, якщо у нього є заплановані візити. |
| **Invoice** → **Payment** | `ON DELETE RESTRICT` | **Заборона** | Не можна видалити рахунок, якщо по ньому вже пройшли реальні кошти. |

---

## Обмеження Цілісності Даних (Data Integrity Constraints)

### CHECK Constraints

```sql
-- Час закінчення має бути пізніше часу початку
ALTER TABLE "Schedule" ADD CONSTRAINT "check_time" 
CHECK ("end_time" > "start_time");

-- Ціна процедури не може бути від'ємною
ALTER TABLE "Procedure" ADD CONSTRAINT "cost_check" 
CHECK ("cost" >= 0);

-- Тривалість процедури має бути додатною
ALTER TABLE "Procedure" ADD CONSTRAINT "duration_check" 
CHECK ("duration_minutes" > 0);

-- Сума рахунку не може бути від'ємною
ALTER TABLE "Invoice" ADD CONSTRAINT "amount_check" 
CHECK ("amount" >= 0);

```

### UNIQUE Constraints

* `Diagnosis` `title` - Унікальні назви хвороб.
* `Procedure` `title` - Унікальні назви процедур.
* `Patient` `phone` - Один номер телефону на одного пацієнта.
* `Invoice` `session_id` - Один сеанс може мати лише один сформований рахунок.
